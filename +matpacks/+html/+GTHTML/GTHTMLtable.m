function [out] = GTHTMLtable(varargin)
% GTHTMLtable - Generate an HTML page with a table of a matrix.
%                  
% function FName = <a href="matlab: doc GTHTMLtable">GTHTMLtable</a>({NAME},MAT,{FORMAT},{COLS,{COLFORMAT}},{ROWS,{ROWFORMAT}},{flag,{...}},'colormap',map);
%
% This is intended to be a simple way to display 2D or 3D table data
% with support for row and column labels. Most arguments are optional, 
% except for the data to be tabulated. Format specifiers are strings
% using the standard <a href="matlab: help sprintf">printf</a> format style. Data must be a 2D table or 
% cell array. Cell arrays can mix strings and numbers.
%
% NAME   : Title for table, must be a string {OPTIONAL}
% MAT    : matrix to be displayed. Can be a list.
% FORMAT : sprintf style format for MAT elements {OPTIONAL}
% COLS      : Column names for table {OPTIONAL}. List of strings or 
%             vector of numbers. Not both.
% COLFORMAT : sprintf style format for column elements {OPTIONAL}
% ROWS      : Row names for table {OPTIONAL}. List of strings or 
%             vector of numbers. Not both.
% ROWFORMAT : sprintf style format for row elements {OPTIONAL}
% 'show'    : Show output {OPTIONAL} will prevent saving of file 
%             unless 'save' is specified.
% 'save'    : Save output to HTML file {OPTIONAL} if show is not 
%             specified the save is default.
% 'new'     : Open a new window {DEFAULT}
% 'old'     : Do not open a new window {OPTIONAL}
% 'colormap': define colormap to color contents, must be followed 
%             by a colormap such as generated by  <a href="matlab: help hsv">hsv(10)</a>
%
% Note: Labels can be either strings or numbers, not both, mixing 
%       will cause strange behavior.
%       Specifying more row labels than rows will cause the row 
%       labels to be truncated.
%       Specifying more column labels than columns will result in 
%       empty columns.                                            
%       Imaginary numbers are not supported.
%       The colormap option is only supported for numeric arrays.
%
% Example:
% % The simplest form
% <a href="matlab: GTHTMLtable(rand([3 5 2]),'show');">[try]</a> GTHTMLtable(rand([3 5 2]),'show');
% % Using a color map to color contents
% <a href="matlab: GTHTMLtable(rand([3 5 2]),'colormap',hsv(10)/2+0.5,'show');">[try]</a> GTHTMLtable(rand([3 5 2]),'colormap',hsv(10)/2+0.5,'show');
% % with column labels
% <a href="matlab: GTHTMLtable('Table name',[1:4; 10:10:40],{'one' 'two' 'three' 'four'},'show');">[try]</a> GTHTMLtable('Table name',[1:4; 10:10:40],{'one' 'two' 'three' 'four'},'show');
% % with row labels and format specifiers
% <a href="matlab: GTHTMLtable('Table name',[1:4; 10:10:40],'%5.3f',[1:4],'%2.2i',{'one' 'two'},'ROW %s','show','old');">[try]</a> GTHTMLtable('Table name',[1:4; 10:10:40],'%5.3f',[1:4],'%2.2i',{'one' 'two'},'ROW %s','show','old');
% % The output argument is the html code, if the save option is not specified.
% <a href="matlab: html = GTHTMLtable([1:4; 10:10:40],{'first' 'second' 'third' 'fourth'},[1 2],'show')">[try]</a> html = GTHTMLtable([1:4; 10:10:40],{'first' 'second' 'third' 'fourth'},[1 2],'show')
% % The output argument is the html filename, if the save option is specified.
% % Nested tables are supported inside cell arrays.
% <a href="matlab: fname = GTHTMLtable('x',{1 [2:3]' 'three' 'four'; 10 20 30 40; 'a' 'e' 'r' 'o'},{'first' 'second' 'third' 'fourth'},{'1' '2' 'three'},'show','save')">[try]</a> fname = GTHTMLtable('x',{1 [2:3]' 'three' 'four'; 10 20 30 40; 'a' 'e' 'r' 'o'},{'first' 'second' 'third' 'fourth'},{'1' '2' 'three'},'show','save')
%
% <a href ="matlab: matpacks.html.GTHTML.GTHTMLtable('MAT',[1:4; 10:10:40],'FORMAT',fors,'COLS',[1:4],'ROWS',{'one' 'two'},'show','old');"> [try]</a>matpacks.html.GTHTML.GTHTMLtable('MAT',[1:4; 10:10:40],'FORMAT',fors,'COLS',[1:4],'ROWS',{'one' 'two'},'show','old');
%
% 
HTML = '';

%varargin = {[] [] [] [] [] [] [] []};
%for ii = 1:nargin,
%  varargin{ii} = varargin{ii};
%end;

% data store
ROWS = [];
COLS = [];

count = 0; % argument counter
SHOW = false;  % Show in web browser
NEW = true;   % open new browser
COLOR = []; % colormap to use
SAVEHTML = false;   % save html to a file
MATFOUND = false;   % flag to indicate if data was found
COLSFOUND = false;  % flag to indicate if column labels were found
ROWSFOUND = false;  % flag to indicate if row labels were found

%add to input vargin
nanrep = true;

% Search through arguments

% valid varargin properties

validVarargin = {'name' 'mat' 'format' 'cols' 'colformat' 'rows' ...
    'rowformat' 'show' 'save' 'new' 'old' 'colormap'};
validvarchar = cellfun(@(x) ischar(x), varargin);
isinput      =find(validvarchar);

%set up the varargin flags and pairs
  [varartest, vararloc] = ismember('show',  lower(varargin(validvarchar)));
  if varartest
    % color cells with colormap specified
    SHOW = varargin{isinput(vararloc)+1};
  end
  if ismember('save',  lower(varargin(validvarchar)))
    % save html to a file
    SAVEHTML = true;
  end
  if ismember('new',  lower(varargin(validvarchar)))
    % open new browser window
    NEW = true;
  end
  if ismember('old',  lower(varargin(validvarchar)))
    % use existing browser window
    NEW = false;
  end
  [varartest, vararloc] = ismember('colormap',  lower(varargin(validvarchar)));
  if varartest
    % color cells with colormap specified
    COLOR = varargin{isinput(vararloc)+1};
  end
  [varartest, vararloc] = ismember('rows', lower(varargin(validvarchar)));

  if varartest
    % labels for rows
    ROWS = varargin{isinput(vararloc)+1};
    ROWSFOUND = true;
  end
  [varartest, vararloc] = ismember('rowformat',  lower(varargin(validvarchar)));
  if varartest
    % format specifier for row labels
    ROWFORMAT = varargin{isinput(vararloc)+1};
  end
  [varartest, vararloc] = ismember('cols',  lower(varargin(validvarchar)));
  if varartest
    % labels for columns
    COLS = varargin{isinput(vararloc)+1};
    COLSFOUND = true;
  end
  [varartest, vararloc] = ismember('colformat',  lower(varargin(validvarchar)));
  if varartest
    % format specifier for column labels
    COLFORMAT = varargin{isinput(vararloc)+1};
  end
  [varartest, vararloc] = ismember('format',  lower(varargin(validvarchar)));
  if varartest
    % format specifier for data 
    FORMAT = varargin{isinput(vararloc)+1};
  end
  [varartest, vararloc] = ismember('mat',  lower(varargin(validvarchar)));
  if varartest
    % data
    MAT = varargin{isinput(vararloc)+1};
    MATname = inputname(isinput(vararloc)+1);
    if isnumeric(MAT),
      MATmax = max(MAT(:));
      MATmin = min(MAT(:));
      MATrange = MATmax - MATmin;
    end;
    MATFOUND = true;
  end
  [varartest, vararloc] = ismember('name',  lower(varargin(validvarchar)));
  if varartest
    % title of table also filename
    NAME = varargin{isinput(vararloc)+1};
  end
  
% while (count<nargin),  
%   count = count+1;
%   
%   if (ischar(varargin{count}) && strcmpi(varargin{count},'show') && count>1),
%     % show table in browser
%     SHOW = true;
%   elseif (ischar(varargin{count}) && strcmpi(varargin{count},'save') && count>1),
%     % save html to a file
%     SAVEHTML = true;
%   elseif (ischar(varargin{count}) && strcmpi(varargin{count},'new') && count>1),
%     % open new browser window
%     NEW = true;
%   elseif (ischar(varargin{count}) && strcmpi(varargin{count},'old') && count>1),
%     % use existing browser window
%     NEW = false;
%   elseif (ischar(varargin{count}) && strcmpi(varargin{count},'colormap') && count>1 && count<nargin),
%     % color cells with colormap specified
%     COLOR = varargin{count+1};
%     count = count + 1;
%   elseif (ischar([varargin{count}]) && count>=3 && count<=7 && ROWSFOUND),
%     % format specifier for row labels
%     ROWFORMAT = varargin{count};
%   elseif (~ischar([varargin{count}]) && count>=2 && count<=6 && COLSFOUND && ~ROWSFOUND),
%     % labels for rows
%     ROWS = varargin{count};
%     ROWSFOUND = true;
%   elseif (ischar([varargin{count}]) && count>=3 && count<=5 && COLSFOUND),
%     % format specifier for column labels
%     COLFORMAT = varargin{count};
%   elseif (~ischar([varargin{count}]) && count>=2 && count<=4 && MATFOUND && ~COLSFOUND),
%     % labels for columns
%     COLS = varargin{count};
%     COLSFOUND = true;
%   elseif (ischar([varargin{count}]) && count>=2 && count<=3 && MATFOUND),
%     % format specifier for data 
%     FORMAT = varargin{count};
%   elseif (~ischar([varargin{count}]) && count>=1 && count<=2 && ~MATFOUND),
%     % data
%     MAT = varargin{count};
%     MATname = inputname(count);
%     if isnumeric(MAT),
%       MATmax = max(MAT(:));
%       MATmin = min(MAT(:));
%       MATrange = MATmax - MATmin;
%     end;
%     MATFOUND = true;
%   elseif (ischar([varargin{count}]) && count ==1),
%     % title of table also filename
%     NAME = varargin{count};
%   end;
% 
% end;

% colormap
 if ~isempty(COLOR),
%   if (~isnumeric(COLOR) || size(COLOR,2)~=3)
  if size(COLOR)~=size(MAT) 
%     warning('GTHTMLTable:colormap','colormap must be [nx3] array');
    warning('GTHTMLTable:colormap','colormap must be same size as MAT');

    COLOR = [];
  end;
end;

% resize MAT
szmat = size(MAT); 
MAT = reshape(MAT,szmat(1),szmat(2),prod(szmat(3:end)));

% create filename
% [pth, name, ext] = fileparts(NAME);
% matpacks.iofun.folderCheckCreate(pth);

if (exist('NAME','var')),
  FILENAME = [NAME '.html'];
else
  FILENAME = 'TABLE.html';
end;

% replace unacceptable characters in filename
I = find(FILENAME=='\' | FILENAME==' ' |  FILENAME=='(' |  FILENAME==')' |  FILENAME=='[' |  FILENAME==']' |  FILENAME=='*');
FILENAME(I) = '_';

% set default row format
if (~exist('ROWFORMAT','var') && ~isempty(ROWS)),
  if (iscell(ROWS(1))),
    if ischar([ROWS{1}]),
      ROWFORMAT = '%s';
    else
      ROWFORMAT = '%g';
    end;
  else
    if length(ROWS(1))>1,
      ROWFORMAT = '%s';
    else
      ROWFORMAT = '%g';
    end;
  end;
end;
% set default column format
if (~exist('COLFORMAT','var') && ~isempty(COLS)),
  if (iscell(COLS(1))),
    if ischar([COLS{1}]),
      COLFORMAT = '%s';
    else
      COLFORMAT = '%g';
    end;
  else
    if length(COLS(1))>1,
      COLFORMAT = '%s';
    else
      COLFORMAT = '%g';
    end;
  end;
end;
% set default data format
if ~exist('FORMAT','var'),
  if ischar(MAT(1)),
    FORMAT = '%s';
  else
    FORMAT = '%0.f';
  end;
  FORMAT = repmat({FORMAT}, [size(MAT)]);
  
else
  if size(FORMAT) ~= size(MAT)
      error('Formats must match data for reporting')
  end
end;


% number of columns to be displayed
if ~isempty(ROWS),
  % add a blank cell if row labels are present
  szcols = size(MAT,2)+1;
else
  szcols = size(MAT,2);
end;

% HTML table
HTML = [HTML sprintf('<TABLE BGCOLOR=gray ALIGN=center>')];
% Table title row
if exist('NAME','var'),
  HTML = [HTML sprintf('<TR><TH COLSPAN=%g ALIGN=CENTER BGCOLOR=#FF0000 style="color:white">%s</TH></TR>',szcols,NAME)];
%  HTML = [HTML sprintf('<TR><TH COLSPAN=%g ALIGN=CENTER BGCOLOR=WHITE>%s</TH></TR>',szcols,NAME)];
end;

% cycle through pages
for ipage = 1:size(MAT,3),
  page = MAT(:,:,ipage);
  if (size(MAT,3) > 1),
    % display page line
    HTML = [HTML sprintf('<TR><TH COLSPAN=%g ALIGN=CENTER BGCOLOR=ivory>%s(:,:,%g)</TH></TR>',szcols,MATname,ipage)];
  end;
  % Column labels
  if ~isempty(COLS),
    HTML = [HTML sprintf('<TR>')];
    if (~isempty(ROWS) && length(COLS)<=size(page,2)),
      HTML = [HTML sprintf('<TD></TD>')];
    end;
    if (iscell(COLS)),
      for jj = 1:length(COLS),
%        HTML = [HTML sprintf(['<TH BGCOLOR=white ALIGN=center>' COLFORMAT '</TH>'],[COLS{jj}])];
        HTML = [HTML sprintf(['<TH BGCOLOR=#0066FF ALIGN=center style="color:white">' COLFORMAT '</TH>'],[COLS{jj}])];
      end;
    else
      HTML = [HTML sprintf(['<TH BGCOLOR=#0066FF ALIGN=center style="color:white">' COLFORMAT '</TH>'],COLS)];
%      HTML = [HTML sprintf(['<TH BGCOLOR=white ALIGN=center>' COLFORMAT '</TH>'],COLS)];
    end;
    HTML = [HTML sprintf('</TR>\n')];
  end;
  % format data rows
  for ii = 1:size(page,1),
    HTML = [HTML sprintf('<TR>\n')];  % new row of data

    % add row label to line
    if ~isempty(ROWS),
      if ii<=length(ROWS),
        if (iscell(ROWS)),
          HTML = [HTML sprintf(['<TH BGCOLOR=#0066FF ALIGN=center style="color:white">' ROWFORMAT '</TH>'],[ROWS{ii}])];
%           HTML = [HTML sprintf(['<TH BGCOLOR=white ALIGN=center>' ROWFORMAT '</TH>'],[ROWS{ii}])];
        else
          HTML = [HTML sprintf(['<TH BGCOLOR=#0066FF ALIGN=center style="color:white">' ROWFORMAT '</TH>'],ROWS(ii))];
%           HTML = [HTML sprintf(['<TH BGCOLOR=white ALIGN=center>' ROWFORMAT '</TH>'],ROWS(ii))];
        end;
      else
        HTML = [HTML sprintf('<TH></TH>')];  % empty row 
      end;
    end;

    % add data 
    if (iscell(page)), % if data is of type cell array
      for jj = 1:length({page{ii,:}}), % columns of data
        % Extract data if single element cell array
        if iscell(page{ii,jj}) && length(page{ii,jj})==1,
          page{ii,jj} = page{ii,jj}{1};
        end;
        % process cell based of content type 
        if iscell(page{ii,jj}) && length(page{ii,jj})>1,
          % create a sub table
          tFORMAT = '%s';             % format for sting
          page{ii,jj} = GTHTMLtable(page{ii,jj});
        elseif ischar(page{ii,jj}),
          tFORMAT = '%s';             % format for sting
        elseif length(page{ii,jj})>1,
          % create a sub table
          tFORMAT = '%s';             % format for sting
          page{ii,jj} = GTHTMLtable(page{ii,jj});
        else
          if ~exist('FORMAT','var'),
            tFORMAT = '%g';
          else
            tFORMAT = FORMAT{ii,jj};         % use user format
          end;
        end;
        if isempty(COLOR)
            HTML = [HTML sprintf(['<TD BGCOLOR=white ALIGN=right>' tFORMAT  '</TD>'],page{ii,jj})]; % add data cell
        else
            HTML = [HTML sprintf(['<TD BGCOLOR=' char(COLOR(ii,jj)) '  ALIGN=right>' tFORMAT  '</TD>'],page{ii,jj})]; % add data cell
        end
      end;
    else  % if data is no a cell array
        % moved loop out so thr formats will work.
        for icol = 1:size(page,2),
          if (~isempty(COLOR) && isnumeric(MAT)),
              % color cells according to value
              %color = dec2hex( floor(255*interp1((0:1/(size(COLOR,1)-1):1),COLOR,(page(ii,icol)-MATmin)/MATrange)) );
              if isnan(page(ii,icol))
                  pgcell = [];
                  fmt = '%s';
              else
                  pgcell = page(ii,icol);
                  fmt = char(FORMAT{ii,icol});
              end
              HTML = [HTML sprintf(['<TD BGCOLOR=' char(COLOR(ii,icol)) ' ALIGN=right>' fmt  '</TD>'], pgcell)]; 
          else
              if isnan(page(ii,icol))
                  pgcell = [];
                  fmt = '%s';
              else
                  pgcell = page(ii,icol);
                  fmt = char(FORMAT{ii,icol});
              end
              HTML = [HTML sprintf(['<TD BGCOLOR=white ALIGN=right>' fmt  '</TD>'],pgcell)]; 
          end;
        end;
    end;
    HTML = [HTML sprintf('\n</TR>')]; % close data row
  end;
end;
HTML = [HTML sprintf('</TABLE>')];  % close table

% Save to html file
if (SAVEHTML),
  FID = fopen(FILENAME,'w');
  fprintf(FID,'%s',HTML);
  fclose(FID);
  disp(sprintf('HTML table saved to file <a href="%s">%s</a>',FILENAME,FILENAME));
  out = FILENAME; % output filename
else
  out = HTML;     % output html code
end;

% display in browser window
if (SHOW),
  if (NEW),
    web(['text://<html>' HTML '</html>'],'-new','-notoolbar');
  else
    web(['text://<html>' HTML '</html>'],'-notoolbar');
  end;
end;


